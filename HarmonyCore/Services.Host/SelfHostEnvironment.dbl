;;*****************************************************************************
;;
;; Title:       SelfHostEnvironment.dbl
;;
;; Description: Environment setup class for a Harmony Core self host program
;;
;;*****************************************************************************
;; WARNING: GENERATED CODE!
;; This file was generated by CodeGen. Avoid editing the file if possible.
;; Any changes you make will be lost of the file is re-generated.
;;*****************************************************************************

import Microsoft.AspNetCore
import Microsoft.AspNetCore.Hosting
import System.Collections.Generic
import System.IO
import System.Text
import Services
import Services.Models

namespace Services.Host

    public partial static class SelfHostEnvironment

        ;;Declare the InitializeCustom partial method
        ;;This method can be implemented in a partial class to provide custom code to initialize the self hosting environment
        partial static method InitializeCustom, void

        endmethod

        public static method Initialize, void

        proc
            ;;Allows select to join when the keys in the file are not the same type as the keys in the code
            data status, int
            xcall setlog("SYNSEL_NUMALPHA_KEYS", 1, status) 

            ;;Configure the test environment (set logicals, create files in a known state, etc.)
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance)
            setLogicals()
            deleteFiles()
            createFiles()

            ;;If we have an InitializeCustom method, call it
            InitializeCustom()

        endmethod

        ;;Declare the CleanupCustom partial method
        ;;This method can be implemented in a partial class to provide custom code to cleanup the self hosting environment before close
        partial static method CleanupCustom, void

        endmethod

        public static method Cleanup, void

        proc
            ;;Delete the data files
            deleteFiles()

            ;;If we have a CleanupCustom method, call it
            CleanupCustom()

        endmethod

        ;;Declare the SetLogicalsCustom partial method
        ;;This method can be implemented in a partial class to provide custom code to define logical names
        partial static method SetLogicalsCustom, void
            required in logicals, @List<string>
        endmethod

        private static method setLogicals, void
        proc
            data sampleDataFolder = findRelativeFolderForAssembly("SampleData")
            Startup.LogicalNames = new List<string>()
            data logical = String.Empty
            data fileSpec = String.Empty

            fileSpec = "DAT:BBQ.ism"
            if (fileSpec.Contains(":")) then
            begin
                logical = fileSpec.Split(":")[1].ToUpper()
                if (!Startup.LogicalNames.Contains(logical))
                    Startup.LogicalNames.Add(logical)
            end
            else if (!fileSpec.Contains("."))
            begin
                if (!Startup.LogicalNames.Contains(fileSpec))
                    Startup.LogicalNames.Add(fileSpec)
            end

            fileSpec = "DAT:Order.ism"
            if (fileSpec.Contains(":")) then
            begin
                logical = fileSpec.Split(":")[1].ToUpper()
                if (!Startup.LogicalNames.Contains(logical))
                    Startup.LogicalNames.Add(logical)
            end
            else if (!fileSpec.Contains("."))
            begin
                if (!Startup.LogicalNames.Contains(fileSpec))
                    Startup.LogicalNames.Add(fileSpec)
            end

            fileSpec = "DAT:User.ism"
            if (fileSpec.Contains(":")) then
            begin
                logical = fileSpec.Split(":")[1].ToUpper()
                if (!Startup.LogicalNames.Contains(logical))
                    Startup.LogicalNames.Add(logical)
            end
            else if (!fileSpec.Contains("."))
            begin
                if (!Startup.LogicalNames.Contains(fileSpec))
                    Startup.LogicalNames.Add(fileSpec)
            end

            fileSpec = "DAT:FAVORITE.ism"
            if (fileSpec.Contains(":")) then
            begin
                logical = fileSpec.Split(":")[1].ToUpper()
                if (!Startup.LogicalNames.Contains(logical))
                    Startup.LogicalNames.Add(logical)
            end
            else if (!fileSpec.Contains("."))
            begin
                if (!Startup.LogicalNames.Contains(fileSpec))
                    Startup.LogicalNames.Add(fileSpec)
            end

            ;;If we have a SetLogicalsCustom method, call it
            SetLogicalsCustom(Startup.LogicalNames)

            ;;Now we'll check each logical. If it already has a value we'll do nothing, otherwise
            ;;we'll set the logical to point to the local folder whose name is identified by the
            ;;user-defined token DATA_FOLDER
            foreach logical in Startup.LogicalNames
            begin
                data sts, int
                data translation, a80
                ;;Is it set?
                xcall getlog(logical,translation,sts)
                if (!sts)
                begin
                    ;;No, we'll set it to SampleData
                    xcall setlog(logical,sampleDataFolder,sts)
                end
            end

        endmethod

        private static method createFiles, void
        proc
            data chout, int
            data dataFile, string
            data xdlFile, string

            data bbqs = loadBbqs()
            data orders = loadOrders()
            data users = loadUsers()
            data favorites = loadFavorites()

            ;;Create and load the bbqs file

            dataFile = "DAT:BBQ.ism"
            xdlFile = "@" + dataFile.ToLower().Replace(".ism",".xdl")

            data bbq, @Bbq
            open(chout=0,o:i,dataFile,FDL:xdlFile)
            foreach bbq in bbqs
                store(chout,bbq.SynergyRecord)
            close chout

            ;;Create and load the orders file

            dataFile = "DAT:Order.ism"
            xdlFile = "@" + dataFile.ToLower().Replace(".ism",".xdl")

            data order, @Order
            open(chout=0,o:i,dataFile,FDL:xdlFile)
            foreach order in orders
                store(chout,order.SynergyRecord)
            close chout

            ;;Create and load the users file

            dataFile = "DAT:User.ism"
            xdlFile = "@" + dataFile.ToLower().Replace(".ism",".xdl")

            data user, @User
            open(chout=0,o:i,dataFile,FDL:xdlFile)
            foreach user in users
                store(chout,user.SynergyRecord)
            close chout

            ;;Create and load the favorites file

            dataFile = "DAT:FAVORITE.ism"
            xdlFile = "@" + dataFile.ToLower().Replace(".ism",".xdl")

            data favorite, @Favorite
            open(chout=0,o:i,dataFile,FDL:xdlFile)
            foreach favorite in favorites
                store(chout,favorite.SynergyRecord)
            close chout

        endmethod

        private static method deleteFiles, void
        proc
            ;;Delete the bbqs file
            try
            begin
                xcall delet("DAT:BBQ.ism")
            end
            catch (e, @NoFileFoundException)
            begin
                nop
            end
            endtry

            ;;Delete the orders file
            try
            begin
                xcall delet("DAT:Order.ism")
            end
            catch (e, @NoFileFoundException)
            begin
                nop
            end
            endtry

            ;;Delete the users file
            try
            begin
                xcall delet("DAT:User.ism")
            end
            catch (e, @NoFileFoundException)
            begin
                nop
            end
            endtry

            ;;Delete the favorites file
            try
            begin
                xcall delet("DAT:FAVORITE.ism")
            end
            catch (e, @NoFileFoundException)
            begin
                nop
            end
            endtry

        endmethod

        public static method loadBbqs, @List<Bbq>
        proc
            data dataFile = "DAT:BBQ.ism"
            data textFile = dataFile.ToLower().Replace(".ism",".txt")
            data bbqCh, int, 0
            data bbqRec, strBbq
            data bbqs = new List<Bbq>()
            data grfa, a10
            open(bbqCh,i:s,textFile)
            repeat
            begin
                reads(bbqCh,bbqRec,eof)
                bbqs.Add(new Bbq(bbqRec, grfa))
            end
        eof,
            close bbqCh
            mreturn bbqs
        endmethod

        public static method loadOrders, @List<Order>
        proc
            data dataFile = "DAT:Order.ism"
            data textFile = dataFile.ToLower().Replace(".ism",".txt")
            data orderCh, int, 0
            data orderRec, strOrder
            data orders = new List<Order>()
            data grfa, a10
            open(orderCh,i:s,textFile)
            repeat
            begin
                reads(orderCh,orderRec,eof)
                orders.Add(new Order(orderRec, grfa))
            end
        eof,
            close orderCh
            mreturn orders
        endmethod

        public static method loadUsers, @List<User>
        proc
            data dataFile = "DAT:User.ism"
            data textFile = dataFile.ToLower().Replace(".ism",".txt")
            data userCh, int, 0
            data userRec, strUser
            data users = new List<User>()
            data grfa, a10
            open(userCh,i:s,textFile)
            repeat
            begin
                reads(userCh,userRec,eof)
                users.Add(new User(userRec, grfa))
            end
        eof,
            close userCh
            mreturn users
        endmethod

        public static method loadFavorites, @List<Favorite>
        proc
            data dataFile = "DAT:FAVORITE.ism"
            data textFile = dataFile.ToLower().Replace(".ism",".txt")
            data favoriteCh, int, 0
            data favoriteRec, strFavorite
            data favorites = new List<Favorite>()
            data grfa, a10
            open(favoriteCh,i:s,textFile)
            repeat
            begin
                reads(favoriteCh,favoriteRec,eof)
                favorites.Add(new Favorite(favoriteRec, grfa))
            end
        eof,
            close favoriteCh
            mreturn favorites
        endmethod

        private static method findRelativeFolderForAssembly, string
            folderName, string
        proc
            data assemblyLocation = ^typeof(SelfHostEnvironment).Assembly.Location
            data currentFolder = Path.GetDirectoryName(assemblyLocation)
            data rootPath = Path.GetPathRoot(currentFolder)
            while(currentFolder != rootPath)
            begin
                if(Directory.Exists(Path.Combine(currentFolder, folderName))) then
                    mreturn Path.Combine(currentFolder, folderName)
                else
                    currentFolder = Path.GetFullPath(currentFolder + "..\")
            end
            mreturn ^null
        endmethod

    endclass

endnamespace